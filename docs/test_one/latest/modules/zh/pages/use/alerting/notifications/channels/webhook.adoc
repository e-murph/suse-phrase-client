= Webhook
:revdate: 2025-07-10
:page-revdate: {revdate}
:description: SUSE 可观察性

Webhooks 是您定义并运行的自定义 HTTP 回调。只要通知被打开或关闭，他们就可以采取任何必要的行动。例如，在 SUSE Observability 本身不支持的票单系统中创建票单。或者直接将通知信息写入 S3 存储桶，以备将来参考。

Webhook 通道<<_webhook_requests_and_payload,通过 HTTP>> 以<<_webhook_requests_and_payload,JSON>> 格式发送通知数据。

== 配置网络钩子

image::k8s/notifications-webhook-channel-configuration.png[配置网络钩子]

要配置网络钩子，请填写以下字段：

. URL - 输入 webhook 端点的 URL。如果 URL 包含特殊字符，则必须按百分比编码。
. 秘密令牌 - SUSE Observability 将在每个请求中包含一个秘密令牌，以<<_validate_the_requests,对其进行验证>>
. 元数据 - 添加包含在有效载荷中的额外键/值对。当同一个端点处理多个 SUSE Observability 网络钩子并需要一些额外信息时，可以使用此功能
. 启用 SSL 验证 -（默认开启）启用 SSL 证书验证。仅在使用自签名证书或 SUSE Observability 不支持的证书颁发机构时禁用

最后选择 "添加频道"。网络钩子通道将显示在右侧。要测试网络钩子是否正常工作，请单击 "测试 "按钮发送测试信息。

== Webhook 请求和有效载荷

Webhook 通道以 HTTP POST 请求的形式发送数据。https://github.com/StackVista/stackstate-openapi/tree/master/spec_webhook[OpenAPI 规范]中记录了端点和有效载荷。

=== 打开通知请求的有效载荷示例

----
{
    "component": {
        "identifier": "urn:kubernetes:/k8s-demo-cluster:sock-shop:service/catalogue",
        "link": "https://play.stackstate.com/#/components/urn%3Akubernetes%3A%2Fk8s-demo-cluster%3Asock-shop%3Aservice%2Fcatalogue?timeRange=1702624556757_1702646156757&timestamp=1702635356757",
        "name": "catalogue",
        "tags": [
            "app.kubernetes.io/component:catalogue",
            "app.kubernetes.io/instance:sock-shop",
            "app.kubernetes.io/managed-by:Helm",
            "app.kubernetes.io/name:sock-shop",
            "app.kubernetes.io/version:0.3.5",
            "cluster-name:k8s-demo-cluster",
            "cluster-type:kubernetes",
            "component-type:kubernetes-service",
            "domain:business",
            "extra-identifier:catalogue",
            "helm.sh/chart:sock-shop",
            "name:catalogue",
            "namespace:sock-shop",
            "service-type:ClusterIP",
            "stackpack:kubernetes"
        ],
        "type": "service"
    },
    "event": {
        "state": "CRITICAL",
        "title": "HTTP - response time - is above 3.0 seconds",
        "triggeredTimeMs": 1702635356757,
        "type": "open"
    },
    "monitor": {
        "identifier": "urn:stackpack:kubernetes-v2:shared:monitor:kubernetes-v2:http-response-time",
        "link": "https://play.stackstate.com/#/monitors/urn%3Astackpack%3Akubernetes-v2%3Ashared%3Amonitor%3Akubernetes-v2%3Ahttp-response-time",
        "name": "HTTP - response time - is above 3 seconds",
        "tags": []
    },
    "notificationConfiguration": {
        "identifier": "urn:system:default:notification-configuration:testing-2",
        "link": "https://play.stackstate.com/#/notifications/urn%3Asystem%3Adefault%3Anotification-configuration%3Atesting-2",
        "name": "Test Notification"
    },
    "notificationId": "836f628c-1258-4500-b1c7-23884e00f439",
    "metadata": {
        "team": "Team A"
    }
}
----

`open` 有效载荷的部分包括

. 组件：通知适用的 SUSE Observability 组件。这包括组件名称、标识符、类型和标记。它还有一个指向 SUSE Observability UI 的链接，可在健康状态发生变化时打开组件
. 事件：触发此通知的事件。它的类型可以是`open` 或`close` （见下一节）。`open` 表示监控器仍处于指定组件的临界（或偏离）状态。`close` 状态表示监控器之前是打开的，但问题已经解决。包括状态和触发时间。此外，还包括`title` ，这是由监视器提供的问题简短描述，与组件亮点页面中显示的标题相同，可能与监视器名称不同，也可能更详细。
. 监控器：触发通知的监控器。在监视器名称、标签和标识符旁边还包括一个链接。该链接将在 SUSE Observability UI 中打开监控器。
. 通知配置：此通知的通知配置。包括名称、标识符和链接。该链接将在 SUSE Observability UI 中打开通知配置。
. 通知 ID：该通知的唯一标识符。另请参阅<<_notification_life_cycle,通知生命周期>>
. 元数据：可以在 webhook 通道上指定元数据。元数据在这里作为一组键/值对一对一地再现。

=== 通知关闭请求有效载荷示例

----
{
    "component": {
        "identifier": "urn:kubernetes:/gke-demo-dev.gcp.stackstate.io:sock-shop:service/catalogue",
        "link": "https://stac-20533-webhook-channel-management-api.preprod.stackstate.io/#/components/urn%3Akubernetes%3A%2Fgke-demo-dev.gcp.stackstate.io%3Asock-shop%3Aservice%2Fcatalogue?timeRange=1702624556757_1702646156757&timestamp=1702635356757",
        "name": "catalogue",
        "tags": [
            "app.kubernetes.io/component:catalogue",
            "app.kubernetes.io/instance:sock-shop",
            "app.kubernetes.io/managed-by:Helm",
            "app.kubernetes.io/name:sock-shop",
            "app.kubernetes.io/version:0.3.5",
            "cluster-name:gke-demo-dev.gcp.stackstate.io",
            "cluster-type:kubernetes",
            "component-type:kubernetes-service",
            "domain:business",
            "extra-identifier:catalogue",
            "helm.sh/chart:sock-shop",
            "name:catalogue",
            "namespace:sock-shop",
            "service-type:ClusterIP",
            "stackpack:kubernetes"
        ],
        "type": "service"
    },
    "event": {
        "reason": "HealthStateResolved",
        "type": "close"
    },
    "monitor": {
        "identifier": "urn:stackpack:kubernetes-v2:shared:monitor:kubernetes-v2:http-response-time",
        "link": "https://stac-20533-webhook-channel-management-api.preprod.stackstate.io/#/monitors/urn%3Astackpack%3Akubernetes-v2%3Ashared%3Amonitor%3Akubernetes-v2%3Ahttp-response-time",
        "name": "HTTP - response time - is above 3 seconds",
        "tags": []
    },
    "notificationConfiguration": {
        "identifier": "urn:system:default:notification-configuration:testing-2",
        "link": "https://stac-20533-webhook-channel-management-api.preprod.stackstate.io/#/notifications/urn%3Asystem%3Adefault%3Anotification-configuration%3Atesting-2",
        "name": "Test Notification"
    },
    "notificationId": "836f628c-1258-4500-b1c7-23884e00f439",
    "tags": {
        "team": "Team A"
    }
}
----

`close` 有效载荷中的部分与`open` 有效载荷中的部分相同，但`event` 除外。`type` 现在是`close` ，只有一个`reason` 字段说明关闭通知的原因。该字段的值是一个枚举，https://github.com/StackVista/stackstate-openapi/tree/master/spec_webhook[OpenAPI 规范]记录了可能的值。

== 通知生命周期

从有效载荷中可以看出，每个通知的唯一标识是`notificationId` 。同一通知收到多条信息是有可能的，甚至是很常见的，但这些信息将始终按照此生命周期发送。

当监控状态变为偏差或临界（偏差是否适用取决于xref:/use/alerting/notifications/configure.adoc#_configure_when_to_notify[通知设置]）时，首先会创建一个xref:/use/alerting/notifications/configure.adoc#_configure_when_to_notify[通知]。事件类型为`open` 的消息会发送到 webhook。

当`state` 或事件中的`title` 发生变化时，可更新通知。组件和信息其他部分的更改将被包括在内，但它们本身不会触发更新。通知更新还会向 webhook 发送事件类型为`open` 的信息。信息将具有相同的`notificationId` ，可用于更新外部系统中的数据（而不是创建新的通知）。

最后，当监控器状态变回非关键（或偏离）状态时，通知就会关闭。事件类型为`close` 的消息会发送到 webhook。这也是最后一次使用特定的`notificationId` 。

请注意，打开和关闭通知的原因可能与健康状态变化不同：

* 为组件或监视器添加标签。这会导致某些关键监控器的健康状态与通知配置中的选择标准相匹配，并打开相应的通知。
* 出于同样的原因，从组件或监控器上移除标签后，即使健康状况仍然危急，也可以关闭通知。
* 更改通知配置本身也会导致许多新通知被打开或关闭。

== 验证请求

通道配置中指定的密令会包含在`X-SUSE Observability-Webhook-Token` 标头的 webhook 请求中。您的 Webhook 端点可以检查该值，以验证请求是否合法。

== 重试

网络钩子通道将重试通知请求，直到收到状态为 200 OK 的响应（响应中的正文将被忽略）。如果 webhook 无法处理消息（例如，当时无法访问数据库），它只需回复 500 状态代码即可。SUSE Observability 会在几秒钟内重新发送相同的信息，希望问题现在已经解决。

如果通知已更新或关闭，旧信息将被丢弃，新的更新信息将被发送并再次重试，直到成功为止。

== 网络钩子示例

要测试网络钩子如何工作，可以使用这个简单的 Python 脚本，它能启动 HTTP 服务器并将接收到的有效负载写入标准输出。

. 将此 Python 脚本保存为`webhook.py` ：
```python
from http.server import HTTPServer, BaseHTTPRequestHandler
import json
import sys

class WebhookHTTPRequestHandler(BaseHTTPRequestHandler):

 def do_POST(self):
     content_len = int(self.headers.get('content-length', 0))
     notification = json.loads(self.rfile.read(content_len))
     print("Notification received: ", json.dumps(notification, indent = 2))
     self.send_response(200)
     self.end_headers()

httpd = HTTPServer(('', int(sys.argv[1])), WebhookHTTPRequestHandler)
httpd.serve_forever()
```

. 在未使用的端口（如 8000）上运行网络钩子服务器： `python3 webhook.py 8000`
. 使用 Webhook 服务器的 URL 在 SUSE Observability 中配置 Webhook `http://webhook.example.com:8000`
. 在网络钩子通道上单击`test` 

[NOTE]
====
Webhook 的 URL 必须能被 SUSE Observability 访问，因此仅使用 localhost 地址或本地 IP 地址是不够的。
====


该示例没有对请求进行身份验证，可以通过验证<<_validate_the_requests,令牌标头>>的值来添加身份验证。

与其手工植入，还可以使用https://github.com/StackVista/stackstate-openapi/tree/master/spec_webhook[OpenAPI 规范]，以https://openapi-generator.tech/[OpenAPI 生成器项目]支持的任何语言服务器实现。

== 相关

* xref:/use/alerting/notifications/troubleshooting.adoc[故障排除]
